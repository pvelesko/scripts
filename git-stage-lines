#!/usr/bin/env python3
"""
Non-interactive utility to stage specific lines from a file's unstaged diff.

Usage:
    git-stage-lines <file> <range> [<range> ...]
    
Where <range> is:
    - 10          single line
    - 10-20       inclusive range
    - 10:20       inclusive range (alternative syntax)
    
Flags:
    --dry-run, -n     print filtered patch without applying
    --verbose, -v     show what's being staged
"""

import sys
import re
import subprocess
import argparse
from typing import List, Tuple, Set, Optional


def parse_range(s: str) -> Tuple[int, int]:
    """Parse a range string like '10', '10-20', or '10:20' into (start, end)."""
    if ':' in s:
        parts = s.split(':')
    elif '-' in s:
        parts = s.split('-')
    else:
        # Single line
        line = int(s)
        return (line, line)
    
    if len(parts) != 2:
        raise ValueError(f"Invalid range format: {s}")
    
    start = int(parts[0])
    end = int(parts[1])
    
    if start > end:
        raise ValueError(f"Range start ({start}) must be <= end ({end})")
    
    return (start, end)


def normalize_ranges(ranges: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    """Merge overlapping ranges and sort them."""
    if not ranges:
        return []
    
    # Sort by start
    sorted_ranges = sorted(ranges, key=lambda x: x[0])
    
    # Merge overlapping/adjacent ranges
    merged = [sorted_ranges[0]]
    for start, end in sorted_ranges[1:]:
        last_start, last_end = merged[-1]
        if start <= last_end + 1:  # Overlapping or adjacent
            merged[-1] = (last_start, max(last_end, end))
        else:
            merged.append((start, end))
    
    return merged


def in_range(line: int, ranges: List[Tuple[int, int]]) -> bool:
    """Check if a line number falls within any of the given ranges."""
    for start, end in ranges:
        if start <= line <= end:
            return True
    return False


def get_diff(filepath: str) -> str:
    """Get the unstaged diff for a file."""
    try:
        result = subprocess.run(
            ['git', 'diff', '--', filepath],
            capture_output=True,
            text=True,
            check=True
        )
        return result.stdout
    except subprocess.CalledProcessError as e:
        if e.returncode == 128:
            # Not a git repo or file not found
            sys.stderr.write(f"Error: {filepath} not found or not in git repo\n")
            sys.exit(1)
        raise


def parse_hunk_header(line: str) -> Optional[Tuple[int, int, int, int]]:
    """Parse a hunk header: @@ -old_start,old_count +new_start,new_count @@
    Returns (old_start, old_count, new_start, new_count) or None if not a hunk header.
    """
    match = re.match(r'^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@', line)
    if not match:
        return None
    
    old_start = int(match.group(1))
    old_count = int(match.group(2) or 1)
    new_start = int(match.group(3))
    new_count = int(match.group(4) or 1)
    
    return (old_start, old_count, new_start, new_count)


def filter_hunk(lines: List[str], hunk_start: int, target_ranges: List[Tuple[int, int]]) -> Tuple[List[str], bool]:
    """Filter a hunk to only include changes in the target ranges.
    
    Returns (filtered_lines, has_changes)
    """
    filtered = []
    new_line = hunk_start
    has_changes = False
    
    for line in lines:
        if not line:
            continue
        
        prefix = line[0]
        content = line[1:]
        
        if prefix == ' ':  # Context line
            filtered.append(line)
            new_line += 1
        elif prefix == '+':  # Addition
            if in_range(new_line, target_ranges):
                filtered.append(line)
                has_changes = True
            # Otherwise drop it entirely
            new_line += 1
        elif prefix == '-':  # Deletion
            if in_range(new_line, target_ranges):
                filtered.append(line)
                has_changes = True
            else:
                # Convert to context line
                filtered.append(' ' + content)
            # Deletions don't advance new_line (they don't exist in working tree)
        else:
            # Unknown line type, keep as-is (shouldn't happen in unified diff)
            filtered.append(line)
    
    return filtered, has_changes


def recalculate_hunk_header(old_start: int, filtered_lines: List[str]) -> str:
    """Recalculate hunk header counts based on filtered lines."""
    old_count = 0
    new_count = 0
    
    for line in filtered_lines:
        if not line:
            continue
        prefix = line[0]
        if prefix in ' -':  # Context or deletion (exists in old file)
            old_count += 1
        if prefix in ' +':  # Context or addition (exists in new file)
            new_count += 1
    
    # Format: @@ -old_start,old_count +new_start,new_count @@
    # We don't know new_start here, so we'll need to track it separately
    return f"@@ -{old_start},{old_count} +{old_start},{new_count} @@"


def filter_diff(diff: str, target_ranges: List[Tuple[int, int]], verbose: bool = False) -> str:
    """Filter a unified diff to only include changes in the target ranges."""
    if not diff.strip():
        return ""
    
    lines = diff.split('\n')
    output_lines = []
    i = 0
    
    # Copy all diff header lines (diff --git, index, --- a/..., +++ b/...)
    while i < len(lines):
        line = lines[i]
        if line.startswith('diff --git') or line.startswith('index ') or \
           line.startswith('---') or line.startswith('+++') or \
           line.startswith('new file') or line.startswith('deleted file') or \
           line.startswith('old mode') or line.startswith('new mode') or \
           line.startswith('rename from') or line.startswith('rename to'):
            output_lines.append(line)
            i += 1
        elif line.startswith('@@'):
            # Start of first hunk
            break
        else:
            # Empty line or other header content, skip
            i += 1
    
    # Process hunks
    while i < len(lines):
        line = lines[i]
        
        # Check if this is a hunk header
        hunk_info = parse_hunk_header(line)
        if hunk_info:
            old_start, old_count, new_start, new_count = hunk_info
            
            # Collect hunk body lines
            hunk_lines = [line]  # Include header
            i += 1
            
            # Collect until next hunk header or end of diff
            while i < len(lines):
                if lines[i].startswith('@@'):
                    break
                if lines[i].startswith('\\'):  # No newline at end of file marker
                    hunk_lines.append(lines[i])
                    i += 1
                    break
                hunk_lines.append(lines[i])
                i += 1
            
            # Filter the hunk
            body_lines = hunk_lines[1:]  # Skip header
            filtered_body, has_changes = filter_hunk(body_lines, new_start, target_ranges)
            
            if has_changes:
                # Recalculate hunk header
                old_count_new = sum(1 for l in filtered_body if l and l[0] in ' -')
                new_count_new = sum(1 for l in filtered_body if l and l[0] in ' +')
                
                # Rebuild hunk header
                new_header = f"@@ -{old_start},{old_count_new} +{new_start},{new_count_new} @@"
                output_lines.append(new_header)
                output_lines.extend(filtered_body)
                
                if verbose:
                    added = sum(1 for l in filtered_body if l and l[0] == '+')
                    removed = sum(1 for l in filtered_body if l and l[0] == '-')
                    sys.stderr.write(f"Staging hunk at line {new_start}: +{added} -{removed}\n")
        else:
            # Not a hunk header, skip (shouldn't happen in well-formed diff)
            i += 1
    
    return '\n'.join(output_lines) + '\n'


def main():
    parser = argparse.ArgumentParser(
        description='Stage specific lines from a file\'s unstaged diff',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  git-stage-lines foo.c 10              # Stage line 10
  git-stage-lines foo.c 10-20           # Stage lines 10-20
  git-stage-lines foo.c 5-10 25 30-40   # Stage multiple ranges
  git-stage-lines foo.c 10-20 --dry-run # Preview what would be staged
        """
    )
    parser.add_argument('file', help='File to stage lines from')
    parser.add_argument('ranges', nargs='+', help='Line ranges (e.g., 10, 10-20, 10:20)')
    parser.add_argument('-n', '--dry-run', action='store_true',
                       help='Print filtered patch without applying')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Show what\'s being staged')
    
    args = parser.parse_args()
    
    # Parse and normalize ranges
    try:
        parsed_ranges = [parse_range(r) for r in args.ranges]
        normalized_ranges = normalize_ranges(parsed_ranges)
    except ValueError as e:
        sys.stderr.write(f"Error parsing ranges: {e}\n")
        sys.exit(1)
    
    if args.verbose:
        range_strs = [f"{s}-{e}" if s != e else str(s) for s, e in normalized_ranges]
        sys.stderr.write(f"Target ranges: {', '.join(range_strs)}\n")
    
    # Get diff
    diff = get_diff(args.file)
    
    if not diff.strip():
        sys.stderr.write(f"No unstaged changes found in {args.file}\n")
        sys.exit(0)
    
    # Check for binary/untracked file indicators
    if diff.startswith('Binary files differ') or 'diff --git' not in diff:
        if 'new file' in diff.lower() or 'deleted file' in diff.lower():
            sys.stderr.write(f"Error: {args.file} appears to be untracked or deleted.\n")
            sys.stderr.write("For new files, use 'git add -N <file>' first, then stage specific lines.\n")
            sys.exit(1)
        sys.stderr.write(f"Error: {args.file} appears to be a binary file or has no diff.\n")
        sys.exit(1)
    
    # Filter diff
    filtered_diff = filter_diff(diff, normalized_ranges, verbose=args.verbose)
    
    if not filtered_diff.strip() or filtered_diff.strip() == diff.split('\n')[0] + '\n' + diff.split('\n')[1] + '\n':
        # Only headers, no actual changes
        sys.stderr.write("No changes found in the specified line ranges.\n")
        sys.exit(0)
    
    # Apply or print
    if args.dry_run:
        print(filtered_diff, end='')
    else:
        # Apply via git apply --cached
        proc = subprocess.Popen(
            ['git', 'apply', '--cached', '--'],
            stdin=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True
        )
        stdout, stderr = proc.communicate(input=filtered_diff)
        
        if proc.returncode != 0:
            sys.stderr.write(f"Error applying patch:\n{stderr}\n")
            sys.exit(1)
        
        if args.verbose:
            sys.stderr.write(f"Successfully staged changes from {args.file}\n")


if __name__ == '__main__':
    main()
